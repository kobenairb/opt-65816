.include "hdr.asm"
.accu 16
.index 16
.16bit
.define __main_locals 0

.SECTION ".text_0x0" SUPERFREE

main:
; sub sp,#__main_locals
.ifgr __main_locals 0
tsa
sec
sbc #__main_locals
tas
.endif
; call r 0x2f0
jsr.l consoleInit
; load 0
; type 132 reg 0x12f0 extra 0x0
; ld4 #tilesetend + 0, tcc__r0 (type 0x84)
lda.w #:tilesetend
sta.b tcc__r0h
lda.w #tilesetend + 0
sta.b tcc__r0
; load 1
; type 132 reg 0x12f0 extra 0x0
; ld4 #tileset + 0, tcc__r1 (type 0x84)
lda.w #:tileset
sta.b tcc__r1h
lda.w #tileset + 0
sta.b tcc__r1
; gen_opi len 4 op -
; sbc tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x84 c 0 r type 0x11)
; length xxy 4 vtop->type 0x84
sec
lda.b tcc__r0
sbc.b tcc__r1
sta.b tcc__r0
; push2 imm r 0xf0
pea.w 8192
; push2 imm r 0xf0
pea.w 16
; push2 imm r 0xf0
pea.w 32
; ldpush before load type 0x10 reg 0x0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push4 imm r 0x52f0
pea.w :palmario
pea.w palmario + 0
; push4 imm r 0x52f0
pea.w :tileset
pea.w tileset + 0
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; call r 0x2f0
jsr.l bgInitTileSet
; add sp, #18
tsa
clc
adc #18
tas
; push1 imm r 0xf0
sep #$20
lda #1
pha
rep #$20
; push2 imm r 0xf0
pea.w 26624
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; call r 0x2f0
jsr.l bgSetMapPtr
; add sp, #4
tsa
clc
adc #4
tas
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push1 imm r 0xf0
sep #$20
lda #1
pha
rep #$20
; call r 0x2f0
jsr.l setMode
; add sp, #2
pla
; push1 imm r 0xf0
sep #$20
lda #1
pha
rep #$20
; call r 0x2f0
jsr.l bgSetDisable
; add sp, #1
tsa
clc
adc #1
tas
; push1 imm r 0xf0
sep #$20
lda #2
pha
rep #$20
; call r 0x2f0
jsr.l bgSetDisable
; add sp, #1
tsa
clc
adc #1
tas
; load 0
; type 132 reg 0x12f0 extra 0x0
; ld4 #gfxsprite_end + 0, tcc__r0 (type 0x84)
lda.w #:gfxsprite_end
sta.b tcc__r0h
lda.w #gfxsprite_end + 0
sta.b tcc__r0
; load 1
; type 132 reg 0x12f0 extra 0x0
; ld4 #gfxsprite + 0, tcc__r1 (type 0x84)
lda.w #:gfxsprite
sta.b tcc__r1h
lda.w #gfxsprite + 0
sta.b tcc__r1
; gen_opi len 4 op -
; sbc tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x84 c 0 r type 0x4)
; length xxy 4 vtop->type 0x84
sec
lda.b tcc__r0
sbc.b tcc__r1
sta.b tcc__r0
; push1 imm r 0xf0
sep #$20
lda #96
pha
rep #$20
; push2 imm r 0xf0
pea.w 0
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push2 imm r 0xf0
pea.w 16
; push4 imm r 0x52f0
pea.w :palsprite
pea.w palsprite + 0
; ldpush before load type 0x10 reg 0x0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; push4 imm r 0x52f0
pea.w :gfxsprite
pea.w gfxsprite + 0
; call r 0x2f0
jsr.l oamInitGfxSet
; add sp, #16
tsa
clc
adc #16
tas
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [xloc,0]
lda.b tcc__r0
sta.l xloc + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #192,tcc__r0
lda.w #192
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [yloc,0]
lda.b tcc__r0
sta.l yloc + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flipx,0]
lda.b tcc__r0
sta.l flipx + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frame,0]
lda.b tcc__r0
sta.l frame + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frameidx,0]
lda.b tcc__r0
sta.l frameidx + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flip,0]
lda.b tcc__r0
sta.l flip + 0
; load 0
; type 17 reg 0x3f0 extra 0x0
; ld1 [xloc + 0], tcc__r0
lda.w #0
sep #$20
lda.l xloc + 0
rep #$20
sta.b tcc__r0
; store r 0x0 fr 0x53f0 ft 0x11 fc 0x0
; st1 tcc__r0, [oamMemory,0]
sep #$20
lda.b tcc__r0
sta.l oamMemory + 0
rep #$20
; load 0
; type 17 reg 0x3f0 extra 0x0
; ld1 [yloc + 0], tcc__r0
lda.w #0
sep #$20
lda.l yloc + 0
rep #$20
sta.b tcc__r0
; store r 0x0 fr 0x53f0 ft 0x11 fc 0x1
; st1 tcc__r0, [oamMemory,1]
sep #$20
lda.b tcc__r0
sta.l oamMemory + 1
rep #$20
; load 0
; type 17 reg 0xf0 extra 0x0
; ld1 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x53f0 ft 0x11 fc 0x2
; st1 tcc__r0, [oamMemory,2]
sep #$20
lda.b tcc__r0
sta.l oamMemory + 2
rep #$20
; load 0
; type 17 reg 0xf0 extra 0xa4
; ld1 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x53f0 ft 0x11 fc 0x3
; st1 tcc__r0, [oamMemory,3]
sep #$20
lda.b tcc__r0
sta.l oamMemory + 3
rep #$20
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push2 imm r 0xf0
pea.w 0
; call r 0x2f0
jsr.l oamSetEx
; add sp, #4
tsa
clc
adc #4
tas
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push2 imm r 0xf0
pea.w 0
; call r 0x2f0
jsr.l oamSetVisible
; add sp, #3
tsa
clc
adc #3
tas
; call r 0x2f0
jsr.l setScreenOn
; push4 imm r 0x52f0
pea.w :tilsetprop
pea.w tilsetprop + 0
; push4 imm r 0x52f0
pea.w :tilesetdef
pea.w tilesetdef + 0
; push4 imm r 0x52f0
pea.w :mapmario
pea.w mapmario + 0
; call r 0x2f0
jsr.l mapLoad
; add sp, #12
tsa
clc
adc #12
tas
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [yloc + 0], tcc__r0
lda.l yloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; call r 0x2f0
jsr.l mapUpdateCamera
; add sp, #4
tsa
clc
adc #4
tas
__local_6:
; gtst inv 1 t 0 v 240 r 5489 ind 5489
; uncond jump: nop
; gtst finished; t 0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [pad_keys + 0], tcc__r0
lda.l pad_keys + 0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [pad0,0]
lda.b tcc__r0
sta.l pad0 + 0
; gtst inv 1 t 0 v 240 r 5761 ind 5761
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [pad0 + 0], tcc__r0
lda.l pad0 + 0
sta.b tcc__r0
; gsym_addr t 0 a 5894 ind 5894
; ERROR no jump found to patch
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 6013 ind 6013
; cmp op 0x95 inv 1 v 243 r 6013
; cmp ne
bne +
; gsym_addr t 0 a 6100 ind 6100
; ERROR no jump found to patch
brl __local_0
+
; gtst finished; t 6013
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [pad0 + 0], tcc__r0
lda.l pad0 + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x6)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #512
sta.b tcc__r0
; gtst inv 1 t 0 v 0 r 6463 ind 6463
; gsym_addr t 0 a 6500 ind 6500
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 6588 ind 6588
; cmp op 0x95 inv 1 v 243 r 6588
; cmp ne
bne +
; gsym_addr t 0 a 6675 ind 6675
brl __local_1
+
; gtst finished; t 6588
; gtst inv 1 t 0 v 240 r 6747 ind 6747
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; gsym_addr t 0 a 6880 ind 6880
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 6968 ind 6968
; cmp op 0x95 inv 1 v 243 r 6968
; cmp ne
bne +
; gsym_addr t 0 a 7055 ind 7055
brl __local_2
+
; gtst finished; t 6968
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0x0
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; sbc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
dec.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [xloc,0]
lda.b tcc__r0
sta.l xloc + 0
__local_2:
; gsym_addr t 6968 a 7564 ind 7564
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #1,tcc__r0
lda.w #1
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flipx,0]
lda.b tcc__r0
sta.l flipx + 0
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [yloc + 0], tcc__r0
lda.l yloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; call r 0x2f0
jsr.l mapUpdateCamera
; add sp, #4
tsa
clc
adc #4
tas
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [flip + 0], tcc__r0
lda.l flip + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0x2
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
inc.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flip,0]
lda.b tcc__r0
sta.l flip + 0
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [flip + 0], tcc__r0
lda.l flip + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x6)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #1
sta.b tcc__r0
; gtst inv 1 t 0 v 0 r 8908 ind 8908
; gsym_addr t 0 a 8945 ind 8945
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 9033 ind 9033
; cmp op 0x95 inv 1 v 243 r 9033
; cmp ne
bne +
; gsym_addr t 0 a 9120 ind 9120
brl __local_3
+
; gtst finished; t 9033
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [frameidx + 0], tcc__r0
lda.l frameidx + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0x0
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
inc.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frameidx,0]
lda.b tcc__r0
sta.l frameidx + 0
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [frameidx + 0], tcc__r0
lda.l frameidx + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #3
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frameidx,0]
lda.b tcc__r0
sta.l frameidx + 0
; load 0
; type 36 reg 0x2f0 extra 0x0
; ld4 #sprTiles + 0, tcc__r0 (type 0x24)
lda.w #:sprTiles
sta.b tcc__r0h
lda.w #sprTiles + 0
sta.b tcc__r0
; load 1
; type 16 reg 0x3f0 extra 0xffffffff
; ld2 [frameidx + 0], tcc__r1
lda.l frameidx + 0
sta.b tcc__r1
; gen_opi len 2 op +
; adc tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x24 c 0 r type 0x10)
; length xxy 4 vtop->type 0x24
clc
lda.b tcc__r0
adc.b tcc__r1
sta.b tcc__r0
; load 1
; type 1 reg 0x1100 extra 0x0
; ld1 [tcc__r0,0],tcc__r1
lda.w #0
sep #$20
lda.b [tcc__r0]
rep #$20
xba
xba
bpl +
ora.w #$ff00
+
sta.b tcc__r1
; store r 0x1 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r1, [frame,0]
lda.b tcc__r1
sta.l frame + 0
__local_3:
; gsym_addr t 9033 a 10674 ind 10674
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [yloc + 0], tcc__r0
lda.l yloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; call r 0x2f0
jsr.l mapGetMetaTile
; add sp, #4
tsa
clc
adc #4
tas
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [tileNo,0]
lda.b tcc__r0
sta.l tileNo + 0
__local_1:
; gsym_addr t 6588 a 11248 ind 11248
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [pad0 + 0], tcc__r0
lda.l pad0 + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x6)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #256
sta.b tcc__r0
; gtst inv 1 t 0 v 0 r 11545 ind 11545
; gsym_addr t 0 a 11584 ind 11584
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 11674 ind 11674
; cmp op 0x95 inv 1 v 243 r 11674
; cmp ne
bne +
; gsym_addr t 0 a 11764 ind 11764
brl __local_4
+
; gtst finished; t 11674
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0x0
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
inc.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [xloc,0]
lda.b tcc__r0
sta.l xloc + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flipx,0]
lda.b tcc__r0
sta.l flipx + 0
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [yloc + 0], tcc__r0
lda.l yloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; call r 0x2f0
jsr.l mapUpdateCamera
; add sp, #4
tsa
clc
adc #4
tas
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [flip + 0], tcc__r0
lda.l flip + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0x2
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
inc.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flip,0]
lda.b tcc__r0
sta.l flip + 0
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [flip + 0], tcc__r0
lda.l flip + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x6)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #1
sta.b tcc__r0
; gtst inv 1 t 0 v 0 r 13585 ind 13585
; gsym_addr t 0 a 13624 ind 13624
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 13714 ind 13714
; cmp op 0x95 inv 1 v 243 r 13714
; cmp ne
bne +
; gsym_addr t 0 a 13804 ind 13804
brl __local_5
+
; gtst finished; t 13714
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [frameidx + 0], tcc__r0
lda.l frameidx + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0x0
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
inc.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frameidx,0]
lda.b tcc__r0
sta.l frameidx + 0
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [frameidx + 0], tcc__r0
lda.l frameidx + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #3
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frameidx,0]
lda.b tcc__r0
sta.l frameidx + 0
; load 0
; type 36 reg 0x2f0 extra 0x0
; ld4 #sprTiles + 0, tcc__r0 (type 0x24)
lda.w #:sprTiles
sta.b tcc__r0h
lda.w #sprTiles + 0
sta.b tcc__r0
; load 1
; type 16 reg 0x3f0 extra 0xffffffff
; ld2 [frameidx + 0], tcc__r1
lda.l frameidx + 0
sta.b tcc__r1
; gen_opi len 2 op +
; adc tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x24 c 0 r type 0x10)
; length xxy 4 vtop->type 0x24
clc
lda.b tcc__r0
adc.b tcc__r1
sta.b tcc__r0
; load 1
; type 1 reg 0x1100 extra 0x0
; ld1 [tcc__r0,0],tcc__r1
lda.w #0
sep #$20
lda.b [tcc__r0]
rep #$20
xba
xba
bpl +
ora.w #$ff00
+
sta.b tcc__r1
; store r 0x1 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r1, [frame,0]
lda.b tcc__r1
sta.l frame + 0
__local_5:
; gsym_addr t 13714 a 15361 ind 15361
; load 0
; type 16 reg 0x3f0 extra 0xffffffff
; ld2 [yloc + 0], tcc__r0
lda.l yloc + 0
sta.b tcc__r0
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
clc
lda.b tcc__r0
adc.w #16
sta.b tcc__r0
; ldpush before load type 0x10 reg 0x0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; call r 0x2f0
jsr.l mapGetMetaTile
; add sp, #4
tsa
clc
adc #4
tas
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [tileNo,0]
lda.b tcc__r0
sta.l tileNo + 0
__local_4:
; gsym_addr t 11674 a 16104 ind 16104
__local_0:
; gsym_addr t 6013 a 16142 ind 16142
; load 0
; type 16 reg 0x3f0 extra 0xffffffff
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; load 1
; type 16 reg 0x3f0 extra 0xffffffff
; ld2 [x_pos + 0], tcc__r1
lda.l x_pos + 0
sta.b tcc__r1
; gen_opi len 2 op -
; sbc tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x11)
; length xxy 2 vtop->type 0x10
sec
lda.b tcc__r0
sbc.b tcc__r1
sta.b tcc__r0
; store r 0x0 fr 0x53f0 ft 0x11 fc 0x0
; st1 tcc__r0, [oamMemory,0]
sep #$20
lda.b tcc__r0
sta.l oamMemory + 0
rep #$20
; load 0
; type 16 reg 0x3f0 extra 0xffffffff
; ld2 [yloc + 0], tcc__r0
lda.l yloc + 0
sta.b tcc__r0
; load 1
; type 16 reg 0x3f0 extra 0xffffffff
; ld2 [y_pos + 0], tcc__r1
lda.l y_pos + 0
sta.b tcc__r1
; gen_opi len 2 op -
; sbc tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x11)
; length xxy 2 vtop->type 0x10
sec
lda.b tcc__r0
sbc.b tcc__r1
sta.b tcc__r0
; store r 0x0 fr 0x53f0 ft 0x11 fc 0x1
; st1 tcc__r0, [oamMemory,1]
sep #$20
lda.b tcc__r0
sta.l oamMemory + 1
rep #$20
; load 0
; type 17 reg 0x3f0 extra 0x0
; ld1 [frame + 0], tcc__r0
lda.w #0
sep #$20
lda.l frame + 0
rep #$20
sta.b tcc__r0
; store r 0x0 fr 0x53f0 ft 0x11 fc 0x2
; st1 tcc__r0, [oamMemory,2]
sep #$20
lda.b tcc__r0
sta.l oamMemory + 2
rep #$20
; load 0
; type 16 reg 0x3f0 extra 0xffffffff
; ld2 [flipx + 0], tcc__r0
lda.l flipx + 0
sta.b tcc__r0
; gen_opi len 2 op 
; shl tcc__r0, #6
lda.b tcc__r0
ldy.w #6
-
asl a
dey
bne -
+
sta.b tcc__r0
; gen_opi len 2 op |
; ora tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x11)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
ora.w #48
sta.b tcc__r0
; load 1
; type 16 reg 0x3f0 extra 0xffffffff
; ld2 [frame + 0], tcc__r1
lda.l frame + 0
sta.b tcc__r1
; gen_opi len 2 op 0xcd
; shr tcc__r1, #8
lda.b tcc__r1
xba
and #$00ff
sta.b tcc__r1
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r1 (0x1) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r1
and.w #1
sta.b tcc__r1
; gen_opi len 2 op |
; ora tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x11)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
ora.b tcc__r1
sta.b tcc__r0
; store r 0x0 fr 0x53f0 ft 0x11 fc 0x3
; st1 tcc__r0, [oamMemory,3]
sep #$20
lda.b tcc__r0
sta.l oamMemory + 3
rep #$20
; call r 0x2f0
jsr.l mapUpdate
; call r 0x2f0
jsr.l WaitForVBlank
; call r 0x2f0
jsr.l mapVblank
; gjmp_addr 5489 at 18497
jmp.w __local_6
; gsym_addr t 18539 a 5489 ind 18539
; gsym_addr t 0 a 18576 ind 18576
; gsym_addr t 0 a 5489 ind 18610
; load 0
; type 0 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; gjmp_addr 0 at 18720
jmp.w __local_7
; gsym_addr t 18759 a 0 ind 18759
__local_7:
; gsym_addr t 18759 a 18793 ind 18793
; add sp, #__main_locals
.ifgr __main_locals 0
tsa
clc
adc #__main_locals
tas
.endif
rtl
.ENDS
.RAMSECTION "ram.data" APPENDTO "globram.data"

sprTiles dsb 4
tilsetprop dsb 128

.ENDS

.SECTION ".data" APPENDTO "glob.data"

.db $0,$2,$4,$6
.db $0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff,$0,$ff
.ENDS

.SECTION ".rodata" SUPERFREE

__local_dummy.rodata: .db 0
.ENDS

.RAMSECTION ".bss" BANK $7e SLOT 2
pad0 dsb 2
xloc dsb 2
yloc dsb 2
flipx dsb 2
frame dsb 2
frameidx dsb 2
flip dsb 2
tileNo dsb 2
.ENDS

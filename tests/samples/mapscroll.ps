.include "hdr.asm"
.accu 16
.index 16
.16bit
.define __main_locals 0

.SECTION ".text_0x0" SUPERFREE

main:
; sub sp,#__main_locals
.ifgr __main_locals 0
tsa
sec
sbc #__main_locals
tas
.endif
; call r 0x2f0
jsr.l consoleInit
; load 0
; type 132 reg 0x12f0 extra 0x0
; ld4 #tilesetend + 0, tcc__r0 (type 0x84)
lda.w #:tilesetend
sta.b tcc__r0h
lda.w #tilesetend + 0
sta.b tcc__r0
; load 1
; type 132 reg 0x12f0 extra 0x0
; ld4 #tileset + 0, tcc__r1 (type 0x84)
lda.w #:tileset
sta.b tcc__r1h
lda.w #tileset + 0
sta.b tcc__r1
; gen_opi len 4 op -
; sbc tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x84 c 0 r type 0x11)
; length xxy 4 vtop->type 0x84
sec
lda.b tcc__r0
sbc.b tcc__r1
sta.b tcc__r0
; push2 imm r 0xf0
pea.w 8192
; push2 imm r 0xf0
pea.w 16
; push2 imm r 0xf0
pea.w 32
; ldpush before load type 0x10 reg 0x0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push4 imm r 0x12f0
pea.w :tilesetpal
pea.w tilesetpal + 0
; push4 imm r 0x12f0
pea.w :tileset
pea.w tileset + 0
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; call r 0x2f0
jsr.l bgInitTileSet
; add sp, #18
tsa
clc
adc #18
tas
; push1 imm r 0xf0
sep #$20
lda #1
pha
rep #$20
; push2 imm r 0xf0
pea.w 26624
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; call r 0x2f0
jsr.l bgSetMapPtr
; add sp, #4
tsa
clc
adc #4
tas
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push1 imm r 0xf0
sep #$20
lda #1
pha
rep #$20
; call r 0x2f0
jsr.l setMode
; add sp, #2
pla
; push1 imm r 0xf0
sep #$20
lda #1
pha
rep #$20
; call r 0x2f0
jsr.l bgSetDisable
; add sp, #1
tsa
clc
adc #1
tas
; push1 imm r 0xf0
sep #$20
lda #2
pha
rep #$20
; call r 0x2f0
jsr.l bgSetDisable
; add sp, #1
tsa
clc
adc #1
tas
; load 0
; type 132 reg 0x12f0 extra 0x0
; ld4 #gfxsprite_end + 0, tcc__r0 (type 0x84)
lda.w #:gfxsprite_end
sta.b tcc__r0h
lda.w #gfxsprite_end + 0
sta.b tcc__r0
; load 1
; type 132 reg 0x12f0 extra 0x0
; ld4 #gfxsprite + 0, tcc__r1 (type 0x84)
lda.w #:gfxsprite
sta.b tcc__r1h
lda.w #gfxsprite + 0
sta.b tcc__r1
; gen_opi len 4 op -
; sbc tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x84 c 0 r type 0x4)
; length xxy 4 vtop->type 0x84
sec
lda.b tcc__r0
sbc.b tcc__r1
sta.b tcc__r0
; push1 imm r 0xf0
sep #$20
lda #96
pha
rep #$20
; push2 imm r 0xf0
pea.w 0
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push2 imm r 0xf0
pea.w 16
; push4 imm r 0x12f0
pea.w :palsprite
pea.w palsprite + 0
; ldpush before load type 0x10 reg 0x0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; push4 imm r 0x12f0
pea.w :gfxsprite
pea.w gfxsprite + 0
; call r 0x2f0
jsr.l oamInitGfxSet
; add sp, #16
tsa
clc
adc #16
tas
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [xloc,0]
lda.b tcc__r0
sta.l xloc + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #192,tcc__r0
lda.w #192
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [yloc,0]
lda.b tcc__r0
sta.l yloc + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flipx,0]
lda.b tcc__r0
sta.l flipx + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frame,0]
lda.b tcc__r0
sta.l frame + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frameidx,0]
lda.b tcc__r0
sta.l frameidx + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flip,0]
lda.b tcc__r0
sta.l flip + 0
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push2 imm r 0xf0
pea.w 0
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [yloc + 0], tcc__r0
lda.l yloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; push2 imm r 0xf0
pea.w 0
; call r 0x2f0
jsr.l oamSet
; add sp, #12
tsa
clc
adc #12
tas
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push2 imm r 0xf0
pea.w 0
; call r 0x2f0
jsr.l oamSetEx
; add sp, #4
tsa
clc
adc #4
tas
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; push2 imm r 0xf0
pea.w 0
; call r 0x2f0
jsr.l oamSetVisible
; add sp, #3
tsa
clc
adc #3
tas
; call r 0x2f0
jsr.l setScreenOn
; push4 imm r 0x12f0
pea.w :tilesetatt
pea.w tilesetatt + 0
; push4 imm r 0x12f0
pea.w :tilesetdef
pea.w tilesetdef + 0
; push4 imm r 0x12f0
pea.w :mapmario
pea.w mapmario + 0
; call r 0x2f0
jsr.l mapLoad
; add sp, #12
tsa
clc
adc #12
tas
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [yloc + 0], tcc__r0
lda.l yloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; call r 0x2f0
jsr.l mapUpdateCamera
; add sp, #4
tsa
clc
adc #4
tas
__local_6:
; gtst inv 1 t 0 v 240 r 5296 ind 5296
; uncond jump: nop
; gtst finished; t 0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [pad_keys + 0], tcc__r0
lda.l pad_keys + 0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [pad0,0]
lda.b tcc__r0
sta.l pad0 + 0
; gtst inv 1 t 0 v 240 r 5568 ind 5568
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [pad0 + 0], tcc__r0
lda.l pad0 + 0
sta.b tcc__r0
; gsym_addr t 0 a 5701 ind 5701
; ERROR no jump found to patch
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 5820 ind 5820
; cmp op 0x95 inv 1 v 243 r 5820
; cmp ne
bne +
; gsym_addr t 0 a 5907 ind 5907
; ERROR no jump found to patch
brl __local_0
+
; gtst finished; t 5820
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [pad0 + 0], tcc__r0
lda.l pad0 + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x0)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #512
sta.b tcc__r0
; gtst inv 1 t 0 v 0 r 6270 ind 6270
; gsym_addr t 0 a 6307 ind 6307
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 6395 ind 6395
; cmp op 0x95 inv 1 v 243 r 6395
; cmp ne
bne +
; gsym_addr t 0 a 6482 ind 6482
brl __local_1
+
; gtst finished; t 6395
; gtst inv 1 t 0 v 240 r 6554 ind 6554
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; gsym_addr t 0 a 6687 ind 6687
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 6775 ind 6775
; cmp op 0x95 inv 1 v 243 r 6775
; cmp ne
bne +
; gsym_addr t 0 a 6862 ind 6862
brl __local_2
+
; gtst finished; t 6775
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0xffd6d428
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
clc
lda.b tcc__r0
adc.w #65535
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [xloc,0]
lda.b tcc__r0
sta.l xloc + 0
__local_2:
; gsym_addr t 6775 a 7409 ind 7409
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #1,tcc__r0
lda.w #1
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flipx,0]
lda.b tcc__r0
sta.l flipx + 0
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [yloc + 0], tcc__r0
lda.l yloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; call r 0x2f0
jsr.l mapUpdateCamera
; add sp, #4
tsa
clc
adc #4
tas
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [flip + 0], tcc__r0
lda.l flip + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0x3d
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
inc.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flip,0]
lda.b tcc__r0
sta.l flip + 0
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [flip + 0], tcc__r0
lda.l flip + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x0)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #1
sta.b tcc__r0
; gtst inv 1 t 0 v 0 r 8754 ind 8754
; gsym_addr t 0 a 8791 ind 8791
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 8879 ind 8879
; cmp op 0x95 inv 1 v 243 r 8879
; cmp ne
bne +
; gsym_addr t 0 a 8966 ind 8966
brl __local_3
+
; gtst finished; t 8879
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [frameidx + 0], tcc__r0
lda.l frameidx + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0x30ffffff
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
inc.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frameidx,0]
lda.b tcc__r0
sta.l frameidx + 0
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [frameidx + 0], tcc__r0
lda.l frameidx + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #3
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frameidx,0]
lda.b tcc__r0
sta.l frameidx + 0
; load 0
; type 36 reg 0x2f0 extra 0x0
; ld4 #sprTiles + 0, tcc__r0 (type 0x24)
lda.w #:sprTiles
sta.b tcc__r0h
lda.w #sprTiles + 0
sta.b tcc__r0
; load 1
; type 16 reg 0x3f0 extra 0x0
; ld2 [frameidx + 0], tcc__r1
lda.l frameidx + 0
sta.b tcc__r1
; gen_opi len 2 op +
; adc tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x24 c 0 r type 0x10)
; length xxy 4 vtop->type 0x24
clc
lda.b tcc__r0
adc.b tcc__r1
sta.b tcc__r0
; load 1
; type 1 reg 0x1100 extra 0x0
; ld1 [tcc__r0,0],tcc__r1
lda.w #0
sep #$20
lda.b [tcc__r0]
rep #$20
xba
xba
bpl +
ora.w #$ff00
+
sta.b tcc__r1
; store r 0x1 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r1, [frame,0]
lda.b tcc__r1
sta.l frame + 0
__local_3:
; gsym_addr t 8879 a 10520 ind 10520
__local_1:
; gsym_addr t 6395 a 10557 ind 10557
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [pad0 + 0], tcc__r0
lda.l pad0 + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x0)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #256
sta.b tcc__r0
; gtst inv 1 t 0 v 0 r 10854 ind 10854
; gsym_addr t 0 a 10893 ind 10893
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 10983 ind 10983
; cmp op 0x95 inv 1 v 243 r 10983
; cmp ne
bne +
; gsym_addr t 0 a 11073 ind 11073
brl __local_4
+
; gtst finished; t 10983
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0x303532ff
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
inc.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [xloc,0]
lda.b tcc__r0
sta.l xloc + 0
; load 0
; type 16 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flipx,0]
lda.b tcc__r0
sta.l flipx + 0
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [yloc + 0], tcc__r0
lda.l yloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; ldpush before load type 0x10 reg 0x3f0
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; call r 0x2f0
jsr.l mapUpdateCamera
; add sp, #4
tsa
clc
adc #4
tas
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [flip + 0], tcc__r0
lda.l flip + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0x3d
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
inc.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [flip,0]
lda.b tcc__r0
sta.l flip + 0
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [flip + 0], tcc__r0
lda.l flip + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x0)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #1
sta.b tcc__r0
; gtst inv 1 t 0 v 0 r 12902 ind 12902
; gsym_addr t 0 a 12941 ind 12941
; tcc__r0 to compare reg
lda.b tcc__r0 ; DON'T OPTIMIZE
; gtst inv 1 t 0 v 243 r 13031 ind 13031
; cmp op 0x95 inv 1 v 243 r 13031
; cmp ne
bne +
; gsym_addr t 0 a 13121 ind 13121
brl __local_5
+
; gtst finished; t 13031
; load 0
; type 16 reg 0x3f0 extra 0x0
; ld2 [frameidx + 0], tcc__r0
lda.l frameidx + 0
sta.b tcc__r0
; load 1
; type 0 reg 0x0 extra 0x30ffffff
; mov tcc__r0, tcc__r1
lda.b tcc__r0
sta.b tcc__r1
lda.b tcc__r0h
sta.b tcc__r1h
; gen_opi len 2 op +
; adc tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
inc.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frameidx,0]
lda.b tcc__r0
sta.l frameidx + 0
; load 0
; type 16 reg 0x3f0 extra 0x26
; ld2 [frameidx + 0], tcc__r0
lda.l frameidx + 0
sta.b tcc__r0
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r0
and.w #3
sta.b tcc__r0
; store r 0x0 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r0, [frameidx,0]
lda.b tcc__r0
sta.l frameidx + 0
; load 0
; type 36 reg 0x2f0 extra 0x0
; ld4 #sprTiles + 0, tcc__r0 (type 0x24)
lda.w #:sprTiles
sta.b tcc__r0h
lda.w #sprTiles + 0
sta.b tcc__r0
; load 1
; type 16 reg 0x3f0 extra 0x0
; ld2 [frameidx + 0], tcc__r1
lda.l frameidx + 0
sta.b tcc__r1
; gen_opi len 2 op +
; adc tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x24 c 0 r type 0x10)
; length xxy 4 vtop->type 0x24
clc
lda.b tcc__r0
adc.b tcc__r1
sta.b tcc__r0
; load 1
; type 1 reg 0x1100 extra 0x0
; ld1 [tcc__r0,0],tcc__r1
lda.w #0
sep #$20
lda.b [tcc__r0]
rep #$20
xba
xba
bpl +
ora.w #$ff00
+
sta.b tcc__r1
; store r 0x1 fr 0x3f0 ft 0x10 fc 0x0
; st2 tcc__r1, [frame,0]
lda.b tcc__r1
sta.l frame + 0
__local_5:
; gsym_addr t 13031 a 14678 ind 14678
__local_4:
; gsym_addr t 10983 a 14716 ind 14716
__local_0:
; gsym_addr t 5820 a 14754 ind 14754
; load 0
; type 16 reg 0x3f0 extra 0x1
; ld2 [xloc + 0], tcc__r0
lda.l xloc + 0
sta.b tcc__r0
; load 1
; type 16 reg 0x3f0 extra 0x1
; ld2 [x_pos + 0], tcc__r1
lda.l x_pos + 0
sta.b tcc__r1
; gen_opi len 2 op -
; sbc tcc__r1 (0x1), tcc__r0 (0x0) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
sec
lda.b tcc__r0
sbc.b tcc__r1
sta.b tcc__r0
; load 1
; type 16 reg 0x3f0 extra 0x2
; ld2 [yloc + 0], tcc__r1
lda.l yloc + 0
sta.b tcc__r1
; load 2
; type 16 reg 0x3f0 extra 0x2
; ld2 [y_pos + 0], tcc__r2
lda.l y_pos + 0
sta.b tcc__r2
; gen_opi len 2 op -
; sbc tcc__r2 (0x2), tcc__r1 (0x1) (fr type 0x10 c 0 r type 0x10)
; length xxy 2 vtop->type 0x10
sec
lda.b tcc__r1
sbc.b tcc__r2
sta.b tcc__r1
; load 2
; type 16 reg 0x3f0 extra 0xffd6d580
; ld2 [flipx + 0], tcc__r2
lda.l flipx + 0
sta.b tcc__r2
; gen_opi len 2 op &
; and tcc__r240 (0xf0), tcc__r2 (0x2) (fr type 0x10 c 0 r type 0x11)
; length xxy 2 vtop->type 0x10
; nop
lda.b tcc__r2
and.w #255
sta.b tcc__r2
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; ldpush before load type 0x10 reg 0x3f0
; load 3
; type 16 reg 0x3f0 extra 0x0
; ld2 [frame + 0], tcc__r3
lda.l frame + 0
sta.b tcc__r3
; ldpush2 (type 0x10 reg 0x3) tcc__r3
pei (tcc__r3)
; push1 imm r 0xf0
sep #$20
lda #0
pha
rep #$20
; ldpush before load type 0x11 reg 0x2
; ldpush1 (type 0x11 reg 0x2) tcc__r2
sep #$20
lda.b tcc__r2
pha
rep #$20
; push1 imm r 0xf0
sep #$20
lda #3
pha
rep #$20
; ldpush before load type 0x10 reg 0x1
; ldpush2 (type 0x10 reg 0x1) tcc__r1
pei (tcc__r1)
; ldpush before load type 0x10 reg 0x0
; ldpush2 (type 0x10 reg 0x0) tcc__r0
pei (tcc__r0)
; push2 imm r 0xf0
pea.w 0
; call r 0x2f0
jsr.l oamSet
; add sp, #12
tsa
clc
adc #12
tas
; call r 0x2f0
jsr.l mapUpdate
; call r 0x2f0
jsr.l WaitForVBlank
; call r 0x2f0
jsr.l mapVblank
; gjmp_addr 5296 at 16582
jmp.w __local_6
; gsym_addr t 16624 a 5296 ind 16624
; gsym_addr t 0 a 16661 ind 16661
; gsym_addr t 0 a 5296 ind 16695
; load 0
; type 0 reg 0xf0 extra 0x0
; ld2 #0,tcc__r0
lda.w #0
sta.b tcc__r0
; gjmp_addr 0 at 16805
jmp.w __local_7
; gsym_addr t 16844 a 0 ind 16844
__local_7:
; gsym_addr t 16844 a 16878 ind 16878
; add sp, #__main_locals
.ifgr __main_locals 0
tsa
clc
adc #__main_locals
tas
.endif
rtl
.ENDS
.RAMSECTION "ramtmpxfiler94990.data" APPENDTO "globram.data"

sprTiles dsb 4

.ENDS

.SECTION "tmpxfiler94990.data" APPENDTO "glob.data"

.db $0,$2,$4,$6
.ENDS

.SECTION ".rodata" SUPERFREE

__local_dummytmpxfiler94990.rodata: .db 0
.ENDS

.RAMSECTION ".bss" BANK $7e SLOT 2
pad0 dsb 2
xloc dsb 2
yloc dsb 2
flipx dsb 2
frame dsb 2
frameidx dsb 2
flip dsb 2
.ENDS
